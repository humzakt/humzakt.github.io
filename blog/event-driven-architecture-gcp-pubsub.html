<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Event-Driven Architecture on GCP: Pub/Sub, Cloud Tasks, and Cloud Scheduler in Practice — Humza Tareen</title>
  <meta name="description" content="How we orchestrated a 6-phase AI evaluation pipeline with dozens of Pub/Sub topics, dead-letter queues, and zero silent failures.">
  <meta name="author" content="Humza Tareen">
  <meta name="keywords" content="GCP, Pub/Sub, Cloud Tasks, Cloud Scheduler, Event-Driven Architecture, Microservices">
  <link rel="canonical" href="https://humzakt.github.io/blog/event-driven-architecture-gcp-pubsub.html">
  <link rel="author" href="https://humzakt.github.io/llms.txt" type="text/plain" title="LLMs.txt">
  <meta property="og:title" content="Event-Driven Architecture on GCP: Pub/Sub, Cloud Tasks, and Cloud Scheduler in Practice">
  <meta property="og:description" content="How we orchestrated a 6-phase AI evaluation pipeline with dozens of Pub/Sub topics, dead-letter queues, and zero silent failures.">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://humzakt.github.io/blog/event-driven-architecture-gcp-pubsub.html">
  <meta property="og:image" content="https://humzakt.github.io/suit-blue-bg.jpg">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:site_name" content="Humza Tareen">
  <meta property="article:published_time" content="2026-02-08T00:00:00Z">
  <meta property="article:author" content="Humza Tareen">
  <meta property="article:tag" content="GCP">
  <meta property="article:tag" content="Pub/Sub">
  <meta property="article:tag" content="Event-Driven">
  <meta property="article:tag" content="Cloud Tasks">
  <meta property="article:tag" content="Microservices">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Event-Driven Architecture on GCP: Pub/Sub, Cloud Tasks, and Cloud Scheduler in Practice">
  <meta name="twitter:description" content="How we orchestrated a 6-phase AI evaluation pipeline with dozens of Pub/Sub topics, dead-letter queues, and zero silent failures.">
  <meta name="twitter:image" content="https://humzakt.github.io/suit-blue-bg.jpg">
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "Event-Driven Architecture on GCP: Pub/Sub, Cloud Tasks, and Cloud Scheduler in Practice",
    "description": "How we orchestrated a 6-phase AI evaluation pipeline with dozens of Pub/Sub topics, dead-letter queues, and zero silent failures.",
    "image": "https://humzakt.github.io/suit-blue-bg.jpg",
    "author": { "@type": "Person", "name": "Humza Tareen", "url": "https://humzakt.github.io" },
    "publisher": { "@type": "Person", "name": "Humza Tareen" },
    "datePublished": "2026-02-08",
    "dateModified": "2026-02-08",
    "mainEntityOfPage": { "@type": "WebPage", "@id": "https://humzakt.github.io/blog/event-driven-architecture-gcp-pubsub.html" },
    "keywords": ["GCP", "Pub/Sub", "Event-Driven", "Cloud Tasks", "Microservices"],
    "articleSection": "Cloud Architecture"
  }
  </script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer">
  <link rel="stylesheet" href="../styles.css">
  <link rel="alternate" type="application/rss+xml" title="Humza Tareen Blog" href="https://humzakt.github.io/blog/feed.xml">
  <style>
    .blog-post { max-width: 800px; margin: 0 auto; padding: calc(var(--nav-height) + 40px) 24px 80px; }
    .blog-back { display: inline-flex; align-items: center; gap: 8px; color: var(--accent); font-family: var(--font-mono); font-size: 14px; margin-bottom: 32px; }
    .blog-back:hover { gap: 12px; }
    .blog-header { margin-bottom: 40px; }
    .blog-title { font-size: clamp(28px, 5vw, 42px); color: var(--heading); line-height: 1.2; margin-bottom: 16px; font-weight: 700; }
    .blog-meta { display: flex; flex-wrap: wrap; align-items: center; gap: 16px; color: var(--text); font-size: 14px; font-family: var(--font-mono); margin-bottom: 24px; }
    .blog-meta time { color: var(--accent); }
    .blog-tags { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 24px; }
    .blog-tag { font-size: 12px; padding: 4px 12px; border-radius: 20px; background: rgba(100,255,218,0.08); color: var(--accent); font-family: var(--font-mono); }
    .blog-content { color: var(--text-light); line-height: 1.8; font-size: 17px; }
    .blog-content h2 { color: var(--heading); font-size: 24px; margin: 48px 0 16px; font-weight: 600; }
    .blog-content h3 { color: var(--heading); font-size: 20px; margin: 32px 0 12px; font-weight: 600; }
    .blog-content p { margin-bottom: 20px; }
    .blog-content ul, .blog-content ol { margin-bottom: 20px; padding-left: 24px; }
    .blog-content li { margin-bottom: 8px; }
    .blog-content strong { color: var(--heading); font-weight: 600; }
    .blog-content code { font-family: var(--font-mono); font-size: 0.9em; background: var(--bg-light); padding: 2px 6px; border-radius: 4px; color: var(--accent); }
    .blog-content pre { background: var(--bg-light); border: 1px solid var(--card-border); border-radius: 8px; padding: 20px; overflow-x: auto; margin-bottom: 24px; font-size: 14px; line-height: 1.6; }
    .blog-content pre code { background: none; padding: 0; color: var(--text-light); }
    .blog-content a { color: var(--accent); text-decoration: underline; text-underline-offset: 3px; }
    .blog-content a:hover { color: var(--heading); }
    .blog-content table { width: 100%; border-collapse: collapse; margin-bottom: 24px; font-size: 15px; }
    .blog-content th, .blog-content td { padding: 12px 16px; border: 1px solid var(--card-border); text-align: left; }
    .blog-content th { background: var(--bg-light); color: var(--heading); font-weight: 600; }
    .blog-footer { margin-top: 60px; padding-top: 32px; border-top: 1px solid var(--card-border); }
    .blog-author { display: flex; align-items: center; gap: 16px; }
    .blog-author-img { width: 56px; height: 56px; border-radius: 50%; object-fit: cover; }
    .blog-author-info h4 { color: var(--heading); font-size: 16px; }
    .blog-author-info p { color: var(--text); font-size: 14px; }
    .blog-cta { margin-top: 32px; text-align: center; }
    .blog-cta a { display: inline-block; padding: 12px 28px; border: 1px solid var(--accent); color: var(--accent); border-radius: 6px; font-family: var(--font-mono); font-size: 14px; transition: var(--transition); }
    .blog-cta a:hover { background: var(--accent-muted); }
    @media (max-width: 768px) { .blog-post { padding-top: calc(var(--nav-height) + 20px); } .blog-content { font-size: 16px; } }
  </style>
</head>
<body>
  <nav class="nav" id="nav" aria-label="Main navigation">
    <a href="../index.html" class="nav-logo" aria-label="Humza Tareen - Home">HT</a>
    <div class="nav-links" role="list">
      <div class="page-switcher">
        <a href="../engineering.html">Engineering</a>
        <a href="../research.html">Research</a>
      </div>
      <a href="../engineering.html#articles" role="listitem">All Articles</a>
      <a href="../engineering.html#contact" class="nav-cta" role="listitem">Hire Me</a>
    </div>
  </nav>
  <main class="blog-post">
    <a href="../engineering.html#articles" class="blog-back"><i class="fas fa-arrow-left"></i> All Articles</a>
    <article>
      <header class="blog-header">
        <h1 class="blog-title">Event-Driven Architecture on GCP: Pub/Sub, Cloud Tasks, and Cloud Scheduler in Practice</h1>
        <div class="blog-meta">
          <time datetime="2026-02-08">Feb 8, 2026</time>
          <span>&middot;</span>
          <span>9 min read</span>
          <span>&middot;</span>
          <span>Humza Tareen</span>
        </div>
        <div class="blog-tags">
          <span class="blog-tag">GCP</span>
          <span class="blog-tag">Pub/Sub</span>
          <span class="blog-tag">Event-Driven</span>
          <span class="blog-tag">Cloud Tasks</span>
          <span class="blog-tag">Microservices</span>
        </div>
      </header>
      <div class="blog-content">
        
        <h2>Why Event-Driven?</h2>
        <p>Our AI evaluation platform has a problem that REST APIs can't solve cleanly: a single evaluation task takes 5-30 minutes, touches 6 different services, and can fail at any point.</p>
        <p>With synchronous HTTP: timeouts, retries hitting already-completed work, and debugging nightmares. With events: each service subscribes independently. If one fails, it retries from its own checkpoint. Others don't even know.</p>

        <h2>The Pipeline Phases</h2>
        <p>Six phases, each representing a handoff where the next service might fail independently. Phase A creates the task. Phase B preprocesses it. Phase C executes the agent. Phase D collects outputs. Phase E judges and scores. Phase F aggregates and learns. Each phase publishes to a Pub/Sub topic, and the next phase subscribes. If Phase C fails, Phase D doesn't even know a task was attempted. Phase C retries from its checkpoint, and when it succeeds, Phase D picks up the work. This independence is what makes event-driven architecture resilient.</p>

<pre><code>Phase A: Task Creation → (Pub/Sub: task-events)
Phase B: Preprocessing → (Pub/Sub: phase-b-batch-notifications)
Phase C: Agent Execution → (Pub/Sub: phase-c-asset-feed)
Phase D: Output Collection → (Pub/Sub: phase-e-jobs)
Phase E: Judging &amp; Scoring → (Pub/Sub: phase-f-jobs)
Phase F: Aggregation &amp; Learning → (Pub/Sub: evaluation-events)
Consumers: Notification, RAG Sync, Analytics</code></pre>

        <h2>Fan-Out Pattern</h2>
        <p>Our most powerful pattern: one topic, multiple subscriptions. <code>evaluation-events</code> is published to once but consumed by notification service, RAG sync, analytics pipeline, and auto-eval scheduler. Adding a new consumer? Create a subscription. Zero changes to the publisher. Here's how it works:</p>

<pre><code># Publisher (evaluation engine)
publisher = pubsub_v1.PublisherClient()
topic_path = publisher.topic_path(project_id, "evaluation-events")
publisher.publish(topic_path, json.dumps({
    "evaluation_id": "eval_123",
    "status": "completed",
    "score": 0.85
}).encode())

# Multiple subscribers (each independent)
# - notification-service subscribes to send emails
# - rag-service subscribes to update embeddings
# - analytics-service subscribes to update dashboards
# - auto-eval-service subscribes to trigger next batch</code></pre>

        <p>Each subscriber processes the message independently. If the notification service fails, the RAG service still processes the message. This decoupling is what makes fan-out so powerful.</p>

        <h2>Dead-Letter Queues</h2>
        <p>Every production topic has a DLQ with a 5-retry policy. We have a weekly DLQ review. Dead-letter queues catch failures that aren't transient: schema migration issues where the message format changed but old messages are still in the queue, quota limits where Firestore rejects writes because we've hit the daily limit, transient Cloud SQL connection failures that become permanent if the database is actually down. Without DLQs, these would have been silent data loss. Messages would fail, get retried, fail again, and disappear. With DLQs, we see every failure, investigate the root cause, and fix it.</p>

        <h2>Cloud Scheduler for Automation</h2>
        <p>Each scheduled job publishes a message to a Pub/Sub topic. The consuming service doesn't know if the message came from a schedule, a user action, or an API call. We could pause <code>auto-eval-daily</code> in production without touching any service code. Here's the pattern:</p>

<pre><code># Cloud Scheduler job
gcloud scheduler jobs create pubsub auto-eval-daily \
  --schedule="0 2 * * *" \
  --topic=auto-eval-trigger \
  --message-body='{"trigger": "daily", "batch_size": 100}'

# Service handler (doesn't know the source)
def handle_auto_eval(message):
    data = json.loads(message.data)
    # Process the batch - same code path whether
    # triggered by schedule, API, or manual publish
    process_evaluation_batch(data["batch_size"])</code></pre>

        <p>This abstraction means we can test scheduled jobs by manually publishing to the topic, pause them by disabling the scheduler job, or change the schedule without deploying code.</p>

        <h2>Monitoring</h2>
        <p>Every Cloud Run service has an alert at &gt;5% error rate. We also monitor CPU utilization &lt; 10% to auto-detect idle VMs—this saves significant compute costs. But the real value is in the alerting strategy: we alert on error rates, not individual errors. One failed message isn't a problem. A sustained error rate above 5% means something is wrong. We also monitor message age in DLQs—if messages are sitting in DLQs for more than an hour, we investigate. This proactive monitoring catches issues before they become incidents.</p>

        <h2>Pub/Sub vs Cloud Tasks: When to Use Which</h2>
        <p>Pub/Sub is for events—things that happened that other services might care about. An evaluation completed. A task was created. A user signed up. Multiple services might subscribe to the same event. Cloud Tasks is for commands—things you want done exactly once, with retries and deadlines. Send an email. Process a payment. Update a database record. One task, one handler, guaranteed delivery.</p>

        <p>We use Pub/Sub for the evaluation pipeline because multiple services care about evaluation events. We use Cloud Tasks for notification delivery because each email should be sent exactly once, with retries if the email service is down. The distinction matters: Pub/Sub is fire-and-forget events. Cloud Tasks is reliable command execution.</p>

        <h2>Key Lessons</h2>
        <p><strong>Message ordering doesn't matter</strong> if you design correctly. Every message contains enough context to be processed independently. If you need ordering, include a sequence number or timestamp in the message. Don't rely on Pub/Sub's ordering guarantees—they're best-effort and can break under load.</p>

        <p><strong>Acknowledge after commit, not before.</strong> Write first, ack second, always. If you ack before writing to the database, and the write fails, the message is gone forever. If you write first, then ack, and the ack fails, the message will be redelivered—but your idempotency check will prevent duplicate processing.</p>

        <p><strong>Schema evolution is inevitable.</strong> Version your message schemas. Include a <code>version</code> field in every message. When you need to change the schema, publish both old and new versions, update consumers gradually, then deprecate the old version. Don't break existing consumers with breaking changes.</p>

        <p><strong>Pub/Sub for events, Cloud Tasks for commands.</strong> Keep the distinction clear. Events are "something happened." Commands are "do this thing." Mixing them leads to confusion about retry semantics, delivery guarantees, and error handling.</p>
        
      </div>
      <footer class="blog-footer">
        <div class="blog-author">
          <img src="../suit-blue-bg.jpg" alt="Humza Tareen" class="blog-author-img">
          <div class="blog-author-info">
            <h4>Humza Tareen</h4>
            <p>AI Engineer building production systems at scale. <a href="../engineering.html">View full portfolio</a></p>
          </div>
        </div>
        <div class="blog-cta">
          <a href="../engineering.html#articles">Read More Articles</a>
        </div>
      </footer>
    </article>
  </main>
</body>
</html>