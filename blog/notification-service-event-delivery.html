<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Building a Notification Service: Cloud Tasks Delivery, Circuit Breakers, and Webhook Dispatch — Humza Tareen</title>
  <meta name="description" content="How I built a production notification service with Cloud Tasks for reliable delivery, circuit breakers, dead-letter queues, and Alembic migrations.">
  <meta name="author" content="Humza Tareen">
  <meta name="keywords" content="Notifications, Cloud Tasks, Webhooks, Circuit Breaker, FastAPI, PostgreSQL, Alembic, Event-Driven">
  <link rel="canonical" href="https://humzakt.github.io/blog/notification-service-event-delivery.html">
  <link rel="author" href="https://humzakt.github.io/llms.txt" type="text/plain" title="LLMs.txt">
  <meta property="og:title" content="Notification Service: Cloud Tasks, Circuit Breakers, Webhooks">
  <meta property="og:description" content="How I built a production notification service with Cloud Tasks for reliable delivery, circuit breakers, dead-letter queues, and Alembic migrations from scratch.">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://humzakt.github.io/blog/notification-service-event-delivery.html">
  <meta property="og:image" content="https://humzakt.github.io/suit-blue-bg.jpg">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:site_name" content="Humza Tareen">
  <meta property="article:published_time" content="2026-02-08T00:00:00Z">
  <meta property="article:author" content="Humza Tareen">
  <meta property="article:tag" content="Cloud Tasks">
  <meta property="article:tag" content="Webhooks">
  <meta property="article:tag" content="FastAPI">
  <meta property="article:tag" content="PostgreSQL">
  <meta property="article:tag" content="Event-Driven">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Notification Service on GCP">
  <meta name="twitter:description" content="Cloud Tasks for reliable delivery, circuit breakers, dead-letter queues, and Alembic migrations.">
  <meta name="twitter:image" content="https://humzakt.github.io/suit-blue-bg.jpg">
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "Notification Service: Cloud Tasks, Circuit Breakers, Webhooks",
    "description": "How I built a production notification service with Cloud Tasks for reliable delivery, circuit breakers, dead-letter queues, and Alembic migrations from scratch.",
    "image": "https://humzakt.github.io/suit-blue-bg.jpg",
    "author": { "@type": "Person", "name": "Humza Tareen", "url": "https://humzakt.github.io" },
    "publisher": { "@type": "Person", "name": "Humza Tareen" },
    "datePublished": "2026-02-08",
    "dateModified": "2026-02-08",
    "mainEntityOfPage": { "@type": "WebPage", "@id": "https://humzakt.github.io/blog/notification-service-event-delivery.html" },
    "keywords": ["Notifications", "Cloud Tasks", "Webhooks", "Circuit Breaker", "FastAPI", "PostgreSQL", "Alembic", "Event-Driven"],
    "articleSection": "Event-Driven Systems"
  }
  </script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer">
  <link rel="stylesheet" href="../styles.css">
  <link rel="alternate" type="application/rss+xml" title="Humza Tareen Blog" href="https://humzakt.github.io/blog/feed.xml">
  <style>
    .blog-post { max-width: 800px; margin: 0 auto; padding: calc(var(--nav-height) + 40px) 24px 80px; }
    .blog-back { display: inline-flex; align-items: center; gap: 8px; color: var(--accent); font-family: var(--font-mono); font-size: 14px; margin-bottom: 32px; }
    .blog-back:hover { gap: 12px; }
    .blog-header { margin-bottom: 40px; }
    .blog-title { font-size: clamp(28px, 5vw, 42px); color: var(--heading); line-height: 1.2; margin-bottom: 16px; font-weight: 700; }
    .blog-meta { display: flex; flex-wrap: wrap; align-items: center; gap: 16px; color: var(--text); font-size: 14px; font-family: var(--font-mono); margin-bottom: 24px; }
    .blog-meta time { color: var(--accent); }
    .blog-tags { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 24px; }
    .blog-tag { font-size: 12px; padding: 4px 12px; border-radius: 20px; background: rgba(100,255,218,0.08); color: var(--accent); font-family: var(--font-mono); }
    .blog-content { color: var(--text-light); line-height: 1.8; font-size: 17px; }
    .blog-content h2 { color: var(--heading); font-size: 24px; margin: 48px 0 16px; font-weight: 600; }
    .blog-content h3 { color: var(--heading); font-size: 20px; margin: 32px 0 12px; font-weight: 600; }
    .blog-content p { margin-bottom: 20px; }
    .blog-content ul, .blog-content ol { margin-bottom: 20px; padding-left: 24px; }
    .blog-content li { margin-bottom: 8px; }
    .blog-content strong { color: var(--heading); font-weight: 600; }
    .blog-content code { font-family: var(--font-mono); font-size: 0.9em; background: var(--bg-light); padding: 2px 6px; border-radius: 4px; color: var(--accent); }
    .blog-content pre { background: var(--bg-light); border: 1px solid var(--card-border); border-radius: 8px; padding: 20px; overflow-x: auto; margin-bottom: 24px; font-size: 14px; line-height: 1.6; }
    .blog-content pre code { background: none; padding: 0; color: var(--text-light); }
    .blog-content a { color: var(--accent); text-decoration: underline; text-underline-offset: 3px; }
    .blog-content a:hover { color: var(--heading); }
    .blog-content table { width: 100%; border-collapse: collapse; margin-bottom: 24px; font-size: 15px; }
    .blog-content th, .blog-content td { padding: 12px 16px; border: 1px solid var(--card-border); text-align: left; }
    .blog-content th { background: var(--bg-light); color: var(--heading); font-weight: 600; }
    .blog-footer { margin-top: 60px; padding-top: 32px; border-top: 1px solid var(--card-border); }
    .blog-author { display: flex; align-items: center; gap: 16px; }
    .blog-author-img { width: 56px; height: 56px; border-radius: 50%; object-fit: cover; }
    .blog-author-info h4 { color: var(--heading); font-size: 16px; }
    .blog-author-info p { color: var(--text); font-size: 14px; }
    .blog-cta { margin-top: 32px; text-align: center; }
    .blog-cta a { display: inline-block; padding: 12px 28px; border: 1px solid var(--accent); color: var(--accent); border-radius: 6px; font-family: var(--font-mono); font-size: 14px; transition: var(--transition); }
    .blog-cta a:hover { background: var(--accent-muted); }
    @media (max-width: 768px) { .blog-post { padding-top: calc(var(--nav-height) + 20px); } .blog-content { font-size: 16px; } }
  </style>
</head>
<body>
  <nav class="nav" id="nav" aria-label="Main navigation">
    <a href="../index.html" class="nav-logo" aria-label="Humza Tareen - Home">HT</a>
    <div class="nav-links" role="list">
      <div class="page-switcher"><a href="../engineering.html">Engineering</a><a href="../research.html">Research</a></div>
      <a href="../engineering.html#articles" role="listitem">All Articles</a>
      <a href="../engineering.html#contact" class="nav-cta" role="listitem">Hire Me</a>
    </div>
  </nav>
  <main class="blog-post">
    <a href="../engineering.html#articles" class="blog-back"><i class="fas fa-arrow-left"></i> All Articles</a>
    <article>
      <header class="blog-header">
        <h1 class="blog-title">Building a Notification Service: Cloud Tasks Delivery, Circuit Breakers, and Webhook Dispatch</h1>
        <div class="blog-meta"><time datetime="2026-02-08">Feb 8, 2026</time><span>&middot;</span><span>7 min read</span><span>&middot;</span><span>Humza Tareen</span></div>
        <div class="blog-tags">
          <span class="blog-tag">Cloud Tasks</span><span class="blog-tag">Webhooks</span><span class="blog-tag">FastAPI</span><span class="blog-tag">PostgreSQL</span><span class="blog-tag">Event-Driven</span>
        </div>
      </header>
      <div class="blog-content">
        <p>When an AI evaluation completes, a score is generated, or an agent finishes a task, someone needs to know. The notification service is the event-driven delivery backbone—it ensures the right information reaches the right subscribers at the right time, even when things go wrong. This isn't just about sending webhooks—it's about building a system that can handle partial failures, network timeouts, and subscriber outages without losing messages or cascading failures across the platform.</p>

        <h2>The Architecture</h2>
        <p>The notification pipeline follows a clear flow: event sources publish messages to Pub/Sub, the notification service consumes those messages, matches them against a subscription registry, and dispatches them through a delivery pipeline built on Cloud Tasks. Each webhook dispatch is retried with exponential backoff, failed deliveries end up in a dead-letter queue, and circuit breakers prevent one failing subscriber from slowing down deliveries to everyone else.</p>
        <pre><code>Event Sources (Pub/Sub)
    ↓
Notification Service (Cloud Run)
    ↓
Subscription Registry
    ↓
Delivery Pipeline (Cloud Tasks)
    ↓
Webhook Dispatch (with retries)
    ↓
Dead Letter Queue ← Circuit Breaker
    ↓
Observability (correlation IDs)</code></pre>
        <p>Each component exists for a reason. Pub/Sub provides durable message storage and at-least-once delivery guarantees. The subscription registry lets subscribers express interest in specific event types. Cloud Tasks handles the heavy lifting of retries and backoff, ensuring that transient failures don't become permanent message loss. The dead-letter queue captures messages that can't be delivered after exhausting retries, allowing manual intervention and analysis. Circuit breakers prevent a single failing subscriber from consuming all retry capacity, ensuring that healthy subscribers continue to receive notifications even when others are down.</p>

        <h2>The Pydantic v2 Serialization Bug</h2>
        <p>Pydantic v2 changed how it handles validation errors. In v1, validation errors were simple dictionaries that FastAPI could serialize to JSON without issue. In v2, Pydantic embeds the original Python exception object inside validation errors, preserving more context for debugging. This is great for development, but it breaks FastAPI's JSON serialization.</p>
        <p>When a request with invalid data arrived, Pydantic would raise a validation error containing a <code>ValueError</code> exception object. FastAPI tried to serialize this to JSON for the 422 response, but Python exceptions aren't JSON serializable. The serialization failed, FastAPI crashed, and users saw a 500 internal server error instead of the helpful 422 validation error they should have received.</p>
        <p>The fix required a custom exception encoder that knows how to serialize exception objects. We extended FastAPI's <code>jsonable_encoder</code> to handle exceptions by converting them to strings:</p>
        <pre><code># Before: Pydantic v2 wraps exceptions, FastAPI can't serialize them
# -> 422 (validation error) becomes 500 (server error)

# After: Custom exception encoder
from fastapi.encoders import jsonable_encoder

@app.exception_handler(RequestValidationError)
async def validation_handler(request, exc):
    return JSONResponse(
        status_code=422,
        content=jsonable_encoder({"detail": exc.errors()},
                                  custom_encoder={Exception: str})
    )</code></pre>
        <p>Now validation errors serialize correctly, and users get the helpful error messages they need to fix their requests. It's a small change, but it transforms a confusing 500 error into a clear 422 validation error that guides users toward the correct input format.</p>

        <h2>Building the Migration System from Scratch</h2>
        <p>Reliable delivery requires reliable state tracking. You can't know if a notification was delivered without storing delivery attempts. You can't retry failed deliveries without a record of what failed. You can't implement circuit breakers without tracking per-subscriber failure rates. All of this requires a database schema that can evolve as the system grows.</p>
        <p>We built the migration system using Alembic with PostgreSQL 17. The schema covers subscriptions (who wants to receive what), notifications (the events themselves), delivery logs (every delivery attempt with its outcome), and dead-letter queue tables (permanent failures that need manual intervention). Each table has proper indexes for the queries we need to run—finding subscriptions for an event type, retrieving delivery logs for a notification, checking circuit breaker state.</p>
        <p>Schema-first development matters here. You can't retrofit reliable delivery onto a system that doesn't track state. The migration system lets us evolve the schema as we discover new requirements—adding fields for retry policies, circuit breaker state, or delivery metadata—without losing existing data or breaking running code.</p>

        <h2>Cloud Tasks Delivery Pipeline</h2>
        <p>The delivery pipeline is where reliability meets complexity. Cloud Tasks provides at-least-once delivery with automatic retries and exponential backoff, but building a production-ready system on top requires careful design.</p>
        <p>Idempotent handlers are essential. Cloud Tasks may deliver the same task multiple times—network partitions, retries, or race conditions can cause duplicate deliveries. Each handler must check if it's already processed this notification before doing any work. A simple database check prevents duplicate webhook calls even when Cloud Tasks delivers the same task twice.</p>
        <p>Exponential backoff handles transient failures gracefully. A webhook endpoint that's temporarily down gets retried with increasing delays—first after one second, then two, then four, then eight. This gives the endpoint time to recover without overwhelming it with rapid retries. Permanent failures—like 404 Not Found or 401 Unauthorized—are detected early and moved to the dead-letter queue without wasting retry capacity.</p>
        <p>Per-subscriber circuit breakers are the hardest part. If one subscriber's webhook endpoint is down, you don't want its failures to slow down deliveries to all other subscribers. The circuit breaker tracks failure rates per subscriber—when failures exceed a threshold, that subscriber's circuit opens, and new deliveries are paused. After a cooldown period, the circuit half-opens, allowing a test delivery. If it succeeds, the circuit closes and normal delivery resumes. If it fails, the circuit opens again.</p>
        <p>This isolation is critical. Without circuit breakers, a single failing subscriber can consume all retry capacity, delaying notifications to healthy subscribers. With circuit breakers, failing subscribers are isolated, and healthy subscribers continue to receive notifications without delay.</p>

        <h2>What the Audit Revealed</h2>
        <p>A production load test revealed issues that don't show up in development. Under concurrent load, race conditions appeared in the caching layer—multiple requests would check the cache simultaneously, find it empty, and all try to populate it at once. The fix required proper locking and atomic cache operations.</p>
        <p>Unbounded memory growth came from the caching layer never evicting entries. As the system ran, the cache grew without bound, eventually consuming all available memory. Adding a TTL and LRU eviction policy kept memory usage bounded while maintaining cache performance.</p>
        <p>The event publisher was fire-and-forget—events were published to Pub/Sub without waiting for acknowledgment. On transient Pub/Sub failures, events were silently dropped. Adding proper error handling and retry logic ensured that events weren't lost on transient failures.</p>
        <p>Overly permissive CORS headers allowed any origin to make requests to the notification service. While the service still required authentication, the permissive CORS policy was unnecessary and increased the attack surface. Restricting CORS to known origins reduced risk without affecting legitimate clients.</p>
        <p>These issues are lessons about what breaks under production load that you don't catch in development. Race conditions only appear with concurrent requests. Memory leaks only show up over time. Fire-and-forget patterns only fail when the external service has issues. The audit process—systematic load testing, code review, and security scanning—surfaced these issues before they became production incidents.</p>
      </div>
      <footer class="blog-footer">
        <div class="blog-author"><img src="../suit-blue-bg.jpg" alt="Humza Tareen" class="blog-author-img"><div class="blog-author-info"><h4>Humza Tareen</h4><p>AI Engineer building production systems at scale. <a href="../engineering.html">View full portfolio</a></p></div></div>
        <div class="blog-cta"><a href="../engineering.html#articles">Read More Articles</a></div>
      </footer>
    </article>
  </main>
</body>
</html>